package jetbrains.mps.vclang.intentions;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.vclang.prelude.PreludeInitializer;
import com.jetbrains.jetpad.vclang.module.RootModule;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.vclang.behavior.ClassDefinition__BehaviorDescriptor;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import com.jetbrains.jetpad.vclang.typechecking.error.reporter.ListErrorReporter;
import com.jetbrains.jetpad.vclang.module.Namespace;
import com.jetbrains.jetpad.vclang.term.definition.visitor.DefinitionResolveNameVisitor;
import com.jetbrains.jetpad.vclang.typechecking.nameresolver.DummyNameResolver;
import com.jetbrains.jetpad.vclang.term.definition.visitor.DefinitionCheckTypeVisitor;
import jetbrains.mps.vclang.behavior.Definition__BehaviorDescriptor;
import com.jetbrains.jetpad.vclang.term.definition.Definition;
import com.jetbrains.jetpad.vclang.typechecking.error.GeneralError;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.vclang.behavior.AdapterUtils;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;

public class TypeCheckUtils {
  public static String KEY = "typeinfo";
  public static String TYPE = "type";
  public static String ERROR = "error";
  public static Logger tcLog = Logger.wrap(LogManager.getLogger(TypeCheckUtils.class));
  public static void doTypechecking(SNode node) {
    PreludeInitializer.initRefs();
    PreludeInitializer.initUserObjects();
    RootModule.initialize();
    Set<SNode> typeCheckedRoots = SetSequence.fromSet(new HashSet<SNode>());
    Set<SNode> rootsToTypeCheck = SetSequence.fromSet(new HashSet<SNode>());
    SetSequence.fromSet(rootsToTypeCheck).addElement(node);
    int oldRoots;
    do {
      oldRoots = SetSequence.fromSet(rootsToTypeCheck).count();
      for (SNode rootToCheck : SetSequence.fromSet(rootsToTypeCheck)) {
        SetSequence.fromSet(rootsToTypeCheck).addSequence(ListSequence.fromList(ClassDefinition__BehaviorDescriptor.getDependencies_id5LKdqeczslD.invoke(rootToCheck)));
      }
    } while (SetSequence.fromSet(rootsToTypeCheck).count() > oldRoots);

    do {
      oldRoots = SetSequence.fromSet(rootsToTypeCheck).count();
      List<SNode> typeChecked = new ArrayList<SNode>();
      for (SNode rootToCheck : SetSequence.fromSet(rootsToTypeCheck)) {
        if (SetSequence.fromSet(typeCheckedRoots).containsSequence(ListSequence.fromList(ClassDefinition__BehaviorDescriptor.getDependencies_id5LKdqeczslD.invoke(rootToCheck)))) {
          System.out.println("Typechecking " + SPropertyOperations.getString(rootToCheck, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")));
          typeCheckClass(rootToCheck);
          ListSequence.fromList(typeChecked).addElement(rootToCheck);
          SetSequence.fromSet(typeCheckedRoots).addElement(rootToCheck);
        }
      }
      SetSequence.fromSet(rootsToTypeCheck).removeSequence(ListSequence.fromList(typeChecked));
      if (SetSequence.fromSet(rootsToTypeCheck).count() >= oldRoots) {
        tcLog.error("Circular dependency between classes (unsupported in this version of VcLang)", node);
        return;
      }
    } while (SetSequence.fromSet(rootsToTypeCheck).count() > 0);

  }

  public static void typeCheckClass(SNode node) {
    try {
      ListErrorReporter reporter = new ListErrorReporter();
      Namespace classStaticNamespace = RootModule.ROOT;
      DefinitionResolveNameVisitor resolveNameVisitor = new DefinitionResolveNameVisitor(reporter, classStaticNamespace, DummyNameResolver.getInstance());
      DefinitionCheckTypeVisitor definitionVisitor = new DefinitionCheckTypeVisitor(classStaticNamespace, reporter);
      Namespace classNonStaticNamespace = Definition__BehaviorDescriptor.toSourceDefinition_id5NQyKEZGoPp.invoke(node).accept(resolveNameVisitor, null);
      Definition wellTypedDefinition = Definition__BehaviorDescriptor.toSourceDefinition_id5NQyKEZGoPp.invoke(node).accept(definitionVisitor, classNonStaticNamespace);
      int eC = reporter.getErrorList().size();
      tcLog.info((eC == 0 ? "There were no typechecking errors." : ((eC == 1 ? "There was 1 typechecking error." + "" : "There were " + eC + " typechecking errors."))));
      for (GeneralError ge : CollectionSequence.fromCollection(reporter.getErrorList())) {
        SNode n = AdapterUtils.resolveNode(ge.getCause());
        String[] s = ge.toString().split("\n");
        if (n != null) {
          if (SNodeOperations.isInstanceOf(n, MetaAdapterFactory.getConcept(0x2db233bb72db49c3L, 0xadc47ae97f87f8dcL, 0xc23f55100976f5cL, "jetbrains.mps.vclang.structure.Expression"))) {
            n.putUserObject(ERROR, ge.toString());
          } else {
            for (String str : s) {
              tcLog.error(str, n);
            }
          }
        } else {
          for (String str : s) {
            tcLog.error(str);
          }
        }
      }

    } catch (Exception e) {
      com.intellij.openapi.diagnostic.Logger.getInstance(TypeCheckUtils.class).error(e);
    }
  }
}
